# 设计模式

<b class="kw">设计模式</b>
<b class="kw">设计原则</b>
<b class="hide">false</b>

## 设计模式是什么

**设计模式**是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。

设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。

人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。

算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。

模式的概念是由克里斯托佛·亚历山大在其著作 《建筑模式语言》 中首次提出的。 本书介绍了城市设计的 “语言”， 而此类 “语言” 的基本单元就是模式。 模式中可能会包含对窗户应该在多高、 一座建筑应该有多少层以及一片街区应该有多大面积的植被等信息的描述。

埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊和理查德·赫尔姆这四位作者接受了模式的概念。 1994 年， 他们出版了 《设计模式： 可复用面向对象软件的基础》 一书， 将设计模式的概念应用到程序开发领域中。 该书提供了 23 个模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。 由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”， 并且很快进一步简化为 “GoF 的书”。

此后， 人们又发现了几十种面向对象的模式。 ​ “模式方法” 开始在其他程序开发领域中流行起来。 如今， 在面向对象设计领域之外， 人们也提出了许多其他的模式。

## 设计模式争议

> 如果你只有一把铁锤， 那么任何东西看上去都像是钉子。

- 一种针对不完善编程语言的蹩脚解决方案
  - 一些模式诞生之初是由于编程语言“缺陷”使得开发者需要使用相应模式来实现，但是当所选编程语言具备这些抽象能力设计模式则成为蹩脚的解决方案
- 低效的解决方案
  - 过于教条主义地使用设计模式将会使代码复杂化

## 设计模式分类

- **创建型模式**提供创建对象的机制， 增加已有代码的灵活性和可复用性。
  - 工厂方法（FactoryMethod）
  - 抽象工厂（AbstractFactory）
  - 原型（Prototype）
  - 单例（Singleton）

- **结构型模式**介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效
  - 适配器模式（Adapter）
  - 桥接（Bridge）
  - 组合（Composite）
  - 装饰（Decorator）
  - 外观（Facade）
  - 享元（Flyweight）
  - 代理（Proxy）

- **行为模式**负责对象间的高效沟通和职责委派。
  - 责任链（Chain of Responsibility）
  - 命令（Command）
  - 迭代器（Iterator）
  - 中介者（Mediator）
  - 备忘录（Memento）
  - 观察者（Observer）
  - 状态（State）
  - 策略（Strategy）
  - 模板方法（TemplateMethod）
  - 访问者（Visitor）

## 设计原则

没有最好的设计模式，只有合适的设计模式，设计模式的目的在于解决问题而不在于过度设计，在学习设计模式之前，可以先了解下设计原则，才能更好地选择合适的模式，同时在实践模式之前系统地学习设计原则能更好地组织代码。

具体而言，设计原则能够指导代码实践的逻辑拆分、组装。哪些是高内聚的哪些是低耦合的，各自承担怎样的角色，如何提升功能模块的拓展性，又如何降低硬编码的使用。总之设计模式能解决复杂问题，设计原则则是解决编码的细节问题。

### 单一职责 SRP

> SRP 原则体现为:一个对象(方法)只做一件事情。

这句话听上去似乎很简单，细细一想又很难。简单在于，我们编码过程中去定义一些方法（或类）就是希望将复杂问题拆解，定义到这些方法（或类）中，然而随着功能的变化这些拆解似乎又耦合起来了。另一方面，对于处理一些“副作用”时，我们会不自觉地将多件事情放在一起了。

我们常会说 分层、解耦，这些都是 SRP 的体现，大部分设计模式其实都是遵循 SRP 原则的，毕竟在模式中涉及 “角色” 其实就是在分层，将不同模块相互解耦开，希望每个被拆解的功能能够单一职责，如代理模式、迭代器模式、单例模式和装饰者模式等。

就编程范式而言，声明式编程天然就符合了单一职责，可以简单感受下

```js
// 比如实现版本号排序 ['0.12.2', '1.0', '0.3']
arr
  .map(parseHandler) // parseHandler 将版本号转化成数字数组
  .sort(sortHandler) // sortHandler 对数字数组比较大小
  .map(formatHandler) // formatHandler 将数组数组转化成版本号字符串
```

**问题场景**

- 类做了太多不该它管的事（正常人基本能避免）
- 职责扩散导致的问题，即由于不确定因素变更、增多使得内部耦合变得严重（随着功能迭代，大部分人很难一开始就处理好）

举个例子：
页面上有一个搜索框，然后有一个搜索和重置按钮。正常逻辑是点击搜索获取一下输入框的内容然后执行搜索，点击重置是清空输入框然后执行搜索

```js
class InputComponent {
  input(value) {
    this.search = value
  }
  search() {
    get(this.search).then(res => render(res))
  }
  reset() {
    this.search = null
    this.search()
  }
}
```

问题在于如果后续有多个搜索框呢？点击重置将是重置所有输入框，你会发现输入组件承担了搜索和重置的能力，类似的例子还有很多。在早期的需求里，一些功能是“需要耦合”的，因为他们组织起来太简单了。

因此在单一职责原则上不要有太大的负担，需要保证的是足够小的子系统内对外单一职责即可，而不是较大的模块间相互耦合，这样在迭代过程中不需要自上而下地去修改，当然这里有一个小坑就是传递参数。如果一开始参数没有设计好，并且传递层级很大，那么就会造成这类问题，这个问题我们会在 LKP 原则继续探讨。

### 里氏替换 LSP

### 依赖倒置 DIP

### 接口隔离 ISP

### 迪米特法则 LKP

### 开闭原则 OCP

### test
